<!--
 * @Author: your name
 * @Date: 2021-07-03 17:21:34
 * @LastEditTime: 2021-07-03 19:51:13
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: /pe-lesson/微课学习记录/js内存管理.md
-->
# JavaScript内存管理

## 前端为什么要关注内存

- 防止页面占用内存过大，引起客户端卡顿，甚至无响应
- Node.JS使用的是V8引擎，内存对于后端服务的性能至关重要，因为后端服务的持久性，后端更容易内存溢出

## JS的数据类型和JS的内存机制
### 数据类型
- 原始数据类型：字符串（String）,数字（number）,布尔（Boolean）,空对象（Null）,未定义（undefined），Symbol
- 引用类型: 对象（Object），函数，数组也是Object的一种
### 内存空间
在js中，每一个数据都需要一个内存空间，在js中内存分为以下两种。原始数据类型都有固定的大小，存储在栈内存中，由系统直接分配内存空间，我们可以直接对其进行操作，因此原始数据类型都是按值访问。
- 栈内存（stack）
栈是一种运行受限的线性表，只允许在表的一端（栈顶）进行插入和删除的运算，采用的是先进后出的原则。



- 堆内存（heap）


### 原始数据类型和引用类型的区别
### 原始数据类型
原始数据类型的大小是固定的，由系统自动分配内存空间
```js
// 定义变量
var a = 1
var b = 'string'
var c = true
```
  系统会将三个变量依次入栈，变量这时候在内存空间分为两块，一块是变量名，一块是值。js定义变量会先将值放入内存空间，再在相同的作用域中声明一个变量名，此时只是声明变量，并没有赋值，所以它的默认值是undefined，声明变量后，再将变量赋值为我们定义的值，赋值的过程只是将变量名和值进行一个关联，关联成功后，我们定义变量的工作就完成了。
### 引用数据类型
  引用数据类型（对象，数组，引用）的大小是不固定的，在堆内存中存储，js不允许直接访问堆内存，因此无法直接操作对象的堆内存空间，我们在操作对象时，实际上是在操作对象的引用，而不是实际的对象，因此引用数据类型的值都是按引用访问，这个引用可以简单地理解为在栈内存中存放一个以堆内存地址为值，引用对象名为变量名的的变量。
  函数也是引用数据类型的一种，函数一般是将函数代码字符串存放于堆内存中，在栈内存中存放函数名及其引用地址。
```js
function fn(){
  var i = 1
  var j = 2
  console.log(i+j)
}
在浏览器中执行fn 和fn()是两种效果，可以验证函数在堆内存中存放的是起代码段
```

## JS垃圾回收机制

### 垃圾回收
    js引擎找出那些不再使用的变量，然后释放起所用的内存，垃圾回收器会按照固定的时间间隔，周期性的执行这一个操作。

    虽然js使用垃圾回收机制来自动管理内存，但是垃圾回收是一把双刃剑;
  - 优势： 可以大幅简化程序的内存管理代码，降低程序猿的负担，减少因长时间运转而带来的内存泄露问题。
  - 不足：意味着程序猿无法掌握内存。js没有暴露任何关于内存的api。我们无法强迫其进行垃圾回收，更无法干预内存管理。
  
###  引用计数
  - 概念 跟踪记录每个值被引用的次数，如果一个值的引用次数为0，就表示这个值不会被用到了，将此内存释放
  - 原理 每次引用加一，被释放时减一，当这个值的引用次数变成0时，就可以将其内存空间回收

  ```js
  var obj1 = {a:10} // obj1对{a:10}的引用次数+1   
  var obj2 = {b:10} // obj2对{b:10}的引用次数+1 
  obj1 = {} // obj1对{a:10}的引用次数-1  
  obj1 = null // obj1对{a:10}的引用次数归0 
  obj2 = null // obj2对{b:10}的引用次数归0 
  ```
   ```js
  //循环引用 在ie8之前中出现。在函数运行完毕后，变量obj1,obj2被销毁，但是其引用不为0，不会被垃圾回收，多次引用此函数，会导致大量内存泄露
  function fn() {
    var obj1 = {a:10};  // obj1对{a:10}的引用次数+1
    var obj2 = {b:10}; // obj2对{b:10}的引用次数+1
    obj1.a = obj2 // obj1对{a:{b:10}}的引用次数+1
    obj2.b = obj1 // obj2对{b:{a:10}}的引用次数+1
  }
  ```

### 标记清除
 - 概念：标记清除指的是当变量进入环境时，这个变量标记为“进入环境”；而当变量离开环境时，将其标记为“离开环境”，最后垃圾回收器完成内存清除工作，销毁并回收那些被标记为“离开环境”的值所占用的内存空间
 - 执行环境： 执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中
 - 全局执行环境： 是最外围的一个执行环境，根据ECMAScript实现所在的宿主环境不同，表示执行环境的变量对象也不一样。例如在web浏览器中，与全局执行环境相关联的变量对象是Windows对象，在node中，全局执行环境关联的是Global对象。全局环境只有当关闭浏览器或者程序退出时才会被销毁。
 - 局部执行环境：每个函数都有自己的执行关键。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。在函数执行后，栈将其环境弹出，把控制器返回给之前的执行环境。ECMAScript程序中的执行流正是由这个方便的机制控制着
```js
function foo() {
  var a = 10; // 被标记进入环境
  var b = 'hello'; // 被标记进入环境
}
foo(); //执行完毕，a和b被标记离开环境，内存被回收
```

## V8内存管理机制
### 限制内存的原因
- V8最初为浏览器设计，不太可能遇到大量内存的使用场景
- 防止因为垃圾回收所导致的线程暂停执行的时间过长。以1.5g数据为例，一次小的垃圾回收需要50ms以上，做一次非增量的垃圾回收甚至要1s以上，这会导致浏览器线程暂停阻塞。如果需要在nodejs里操作大内存的对象，可以修改设置，也可通过buffer对象避开这种限制，因为buffer对象的内存分配是在c++层面进行的，c++层面的内存不受v8引擎限制
- v8采用的是分代回收的策略，将内存分为两个生代：新生代和老生代。
- v8分别对新生代和老生代采用不同的垃圾回收算法来提升垃圾回收的效率
  
### 新生代垃圾回收
form空间和to空间组成一个semispace；分配对象内存时先在form空间分配，在垃圾回收进行时，会检查form空间中的对象，当对象需要被回收时将其留在form空间，将不需要回收的移动到to空间，然后进行反转将form和to空间进行对换，然后将to空间的内存进行释放；简而言之就是将form空间存放不需要被回收的对象，to空间存放需要被回收的对象。

### 新生代对象的晋升
- 1.在新生代垃圾回收过程中，一个对象多次复制后依然存活，那么将会被认为是生命周期较长的对象，会被移动至老生代中，采用新的算法进行管理
- 2.在from空间和to空间进行反转的过程中，如果to空间中的使用量超过了25%,那么将form中的对象直接晋升至老生代内存

### 老生代垃圾回收
- 老生代内存空间是一个连续的结构
- 标记清除将需要被回收的对象进行标记，在垃圾回收时直接释放相应的地址空间；可能会导致清除后的内存空间不连续
- 标记合并将存活的对象移动到一边，将需要被回收的对象移动至另一半，然后对需要被回收的对象区域进行整体的垃圾回收